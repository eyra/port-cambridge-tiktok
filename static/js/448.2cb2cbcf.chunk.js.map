{"version":3,"file":"static/js/448.2cb2cbcf.chunk.js","mappings":"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","sources":["framework/visualisation/react/ui/workers/visualizationDataFunctions/util.ts","framework/visualisation/react/ui/workers/visualizationDataFunctions/prepareChartData.ts","framework/visualisation/react/ui/workers/visualizationDataFunctions/prepareTextData.ts","framework/visualisation/react/ui/workers/visualizationDataWorker.ts"],"sourcesContent":["import { PropsUITable, TableContext } from '../../../../../types/elements'\nimport { DateFormat } from '../../../../../types/visualizations'\n\nexport function formatDate (\n  dateString: string[],\n  format: DateFormat,\n  minValues: number = 10\n): [string[], Record<string, number> | null] {\n  let formattedDate: string[] = dateString\n  const dateNumbers = dateString.map((date) => new Date(date).getTime())\n  let domain: [number, number] | null = null\n  let formatter: (date: Date) => string = (date) => date.toISOString()\n\n  if (format === 'auto') format = autoFormatDate(dateNumbers, minValues)\n\n  if (format === 'year') formatter = (date) => date.getFullYear().toString()\n\n  if (format === 'quarter') {\n    formatter = (date) => {\n      const year = date.getFullYear().toString()\n      const quarter = Math.floor(date.getMonth() / 3) + 1\n      return `${year}-Q${quarter}`\n    }\n  }\n\n  if (format === 'month') {\n    formatter = (date) => {\n      const year = date.getFullYear().toString()\n      const month = date.toLocaleString('default', { month: 'short' })\n      return `${year}-${month}`\n    }\n  }\n\n  if (format === 'day') {\n    formatter = (date) => {\n      const year = date.getFullYear().toString()\n      const month = date.toLocaleString('default', { month: 'short' })\n      const day = date.getDate().toString()\n      return `${year}-${month}-${day}`\n    }\n  }\n\n  if (format === 'hour') {\n    formatter = (date) => {\n      return date.toISOString().split('T')[1].split(':')[0]\n    }\n  }\n\n  if (format === 'month_cycle') {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat('default', { month: 'long' })\n      return intlFormatter.format(date)\n    }\n    // can be any year, starting at january\n    domain = [new Date('2000-01-01').getTime(), new Date('2001-01-01').getTime()]\n  }\n  if (format === 'weekday_cycle') {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat('default', { weekday: 'long' })\n      return intlFormatter.format(date)\n    }\n    // can be any full week, starting at monday\n    domain = [new Date('2023-11-06').getTime(), new Date('2023-11-13').getTime()]\n  }\n  if (format === 'hour_cycle') {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat('default', { hour: 'numeric', hour12: false })\n      return intlFormatter.format(date)\n    }\n    // can be any day, starting at midnight\n    domain = [new Date('2000-01-01').getTime(), new Date('2000-01-02').getTime()]\n  }\n\n  formattedDate = dateNumbers.map((date) => formatter(new Date(date)))\n  if (domain == null) domain = [Math.min(...dateNumbers), Math.max(...dateNumbers)]\n  const sortableDate: Record<string, number> | null = createSortable(domain, format, formatter)\n\n  return [formattedDate, sortableDate]\n}\n\nfunction autoFormatDate (dateNumbers: number[], minValues: number): DateFormat {\n  const minTime = Math.min(...dateNumbers)\n  const maxTime = Math.max(...dateNumbers)\n\n  let autoFormat: DateFormat = 'hour'\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * minValues) autoFormat = 'day'\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 30 * minValues) autoFormat = 'month'\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 30 * 3 * minValues) autoFormat = 'quarter'\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 365 * minValues) autoFormat = 'year'\n\n  return autoFormat\n}\n\nfunction createSortable (\n  domain: [number, number],\n  interval: string,\n  formatter: (date: Date) => string\n): Record<string, number> | null {\n  // creates a map of datestrings to sortby numbers. Also includes intervalls, so that\n  // addZeroes can be used.\n  const sortable: Record<string, number> = {}\n  const [minTime, maxTime] = domain\n\n  // intervalnumbers don't need to be exact. Just small enough that they never\n  // skip over an interval (e.g., month should be shortest possible month).\n  // Duplicate dates are ignored in set\n  let intervalNumber: number = 0\n  if (interval === 'year') intervalNumber = 1000 * 60 * 60 * 24 * 364\n  if (interval === 'quarter') intervalNumber = 1000 * 60 * 60 * 24 * 28 * 3\n  if (['month', 'month_cycle'].includes(interval)) intervalNumber = 1000 * 60 * 60 * 24 * 28\n  if (['day', 'weekday_cycle'].includes(interval)) intervalNumber = 1000 * 60 * 60 * 24\n  if (['hour', 'hour_cycle'].includes(interval)) intervalNumber = 1000 * 60 * 60\n\n  if (intervalNumber > 0) {\n    for (let i = minTime; i <= maxTime; i += intervalNumber) {\n      const date = new Date(i)\n      const datestring = formatter(date)\n      if (sortable[datestring] !== undefined) continue\n      sortable[datestring] = i\n    }\n  }\n\n  return sortable\n}\n\nexport function tokenize (text: string): string[] {\n  const tokens = text.split(' ')\n  return tokens.filter((token) => /\\p{L}/giu.test(token)) // only tokens with word characters\n}\n\nexport function getTableColumn (table: PropsUITable & TableContext, column: string): string[] {\n  const columnIndex = table.head.cells.findIndex((cell) => cell.text === column)\n  if (columnIndex < 0) throw new Error(`column ${table.id}.${column} not found`)\n  return table.body.rows.map((row) => row.cells[columnIndex].text)\n}\n\nexport function rescaleToRange (\n  value: number,\n  min: number,\n  max: number,\n  newMin: number,\n  newMax: number\n): number {\n  return ((value - min) / (max - min)) * (newMax - newMin) + newMin\n}\n","import { formatDate, getTableColumn } from './util'\nimport { PropsUITable, TableContext } from '../../../../../types/elements'\nimport {\n  TickerFormat,\n  ChartVisualizationData,\n  ChartVisualization\n} from '../../../../../types/visualizations'\n\nexport async function prepareChartData (\n  table: PropsUITable & TableContext,\n  visualization: ChartVisualization\n): Promise<ChartVisualizationData> {\n  if (table.body.rows.length === 0) return emptyVisualizationData(visualization)\n\n  const aggregate = aggregateData(table, visualization)\n  return createVisualizationData(visualization, aggregate)\n}\n\nfunction createVisualizationData (\n  visualization: ChartVisualization,\n  aggregate: Record<string, PrepareAggregatedData>\n): ChartVisualizationData {\n  const visualizationData = emptyVisualizationData(visualization)\n\n  for (const aggdata of Object.values(aggregate)) {\n    for (const group of Object.keys(aggdata.values)) {\n      if (visualizationData.yKeys[group] === undefined) {\n        visualizationData.yKeys[group] = {\n          label: group,\n          secondAxis: aggdata.secondAxis,\n          tickerFormat: aggdata.tickerFormat\n        }\n      }\n    }\n  }\n\n  visualizationData.data = Object.values(aggregate)\n    .sort((a: any, b: any) => (a.sortBy < b.sortBy ? -1 : b.sortBy < a.sortBy ? 1 : 0))\n    .map((d) => {\n      for (const key of Object.keys(d.values)) d.values[key] = Math.round(d.values[key] * 100) / 100\n\n      return {\n        ...d.values,\n        [d.xLabel]: d.xValue,\n        __rowIds: d.rowIds,\n        __sortBy: d.sortBy\n      }\n    })\n\n  return visualizationData\n}\n\nfunction emptyVisualizationData (visualization: ChartVisualization): ChartVisualizationData {\n  return {\n    type: visualization.type,\n    xKey: {\n      label:\n        visualization.group.label !== undefined\n          ? visualization.group.label\n          : visualization.group.column\n    },\n    yKeys: {},\n    data: []\n  }\n}\n\nfunction aggregateData (\n  table: PropsUITable & TableContext,\n  visualization: ChartVisualization\n): Record<string, PrepareAggregatedData> {\n  const aggregate: Record<string, PrepareAggregatedData> = {}\n\n  const { groupBy, xSortable } = prepareX(table, visualization)\n  const rowIds = table.body.rows.map((row) => row.id)\n  const xLabel =\n    visualization.group.label !== undefined ? visualization.group.label : visualization.group.column\n\n  for (const value of visualization.values) {\n    // loop over all y values\n\n    const aggFun = value.aggregate !== undefined ? value.aggregate : 'count'\n    let tickerFormat: TickerFormat = 'default'\n    if (aggFun === 'pct' || aggFun === 'count_pct') tickerFormat = 'percent'\n\n    const yValues = getTableColumn(table, value.column)\n    if (yValues.length === 0) throw new Error(`Y column ${table.id}.${value.column} not found`)\n\n    // If group_by column is specified, the columns in the aggregated data will be the unique group_by columns\n    const yGroup = value.group_by !== undefined ? getTableColumn(table, value.group_by) : null\n\n    // if missing values should be treated as zero, we need to add the missing values after knowing all groups\n    const addZeroes = value.addZeroes ?? false\n    const groupSummary: Record<string, { n: number, sum: number }> = {}\n\n    // if addZeroes, prefill with all possible values\n    if (addZeroes && xSortable != null) {\n      for (const [uniqueValue, sortby] of Object.entries(xSortable)) {\n        aggregate[uniqueValue] = {\n          sortBy: sortby,\n          rowIds: {},\n          xLabel,\n          xValue: uniqueValue,\n          values: {},\n          secondAxis: value.secondAxis,\n          tickerFormat\n        }\n      }\n    }\n\n    for (let i = 0; i < rowIds.length; i++) {\n      // loop over rows of table\n      const xValue = groupBy[i]\n\n      if (visualization.group.range !== undefined) {\n        if (\n          Number(xValue) < visualization.group.range[0] ||\n          Number(xValue) > visualization.group.range[1]\n        ) {\n          continue\n        }\n      }\n\n      // SHOULD GROUP BE IGNORED IF NOT IN group.levels? MAYBE NOT, BECAUSE\n      // THIS COULD HARM INFORMED CONSENT IF THE RESEARCHER IS UNAWARE OF CERTAIN GROUPS\n      // if (visualization.group.levels !== undefined) {\n      //   // formatLevels has xSortable < 0 if no match with levels\n      //   if (xSortable !== null && xSortable[i] < 0) continue\n      // }\n\n      const yValue = yValues[i]\n      const label = value.label !== undefined ? value.label : value.column\n      const group = yGroup != null ? yGroup[i] : label\n\n      const sortBy = xSortable != null ? xSortable[xValue] : groupBy[i]\n\n      // calculate group summary statistics. This is used for the mean, pct and count_pct aggregations\n      if (groupSummary[group] === undefined) groupSummary[group] = { n: 0, sum: 0 }\n      if (aggFun === 'count_pct' || aggFun === 'mean') groupSummary[group].n += 1\n      if (aggFun === 'pct') groupSummary[group].sum += Number(yValue) ?? 0\n\n      if (aggregate[xValue] === undefined) {\n        aggregate[xValue] = {\n          sortBy: sortBy,\n          rowIds: {},\n          xLabel,\n          xValue: String(xValue),\n          values: {},\n          secondAxis: value.secondAxis,\n          tickerFormat\n        }\n      }\n      if (aggregate[xValue].rowIds[group] === undefined) aggregate[xValue].rowIds[group] = []\n      aggregate[xValue].rowIds[group].push(rowIds[i])\n\n      if (aggregate[xValue].values[group] === undefined) aggregate[xValue].values[group] = 0\n      if (aggFun === 'count' || aggFun === 'count_pct') aggregate[xValue].values[group] += 1\n      if (aggFun === 'sum' || aggFun === 'mean' || aggFun === 'pct') {\n        aggregate[xValue].values[group] += Number(yValue) ?? 0\n      }\n    }\n\n    // use groupSummary to calculate the mean, pct and count_pct aggregations\n    Object.keys(groupSummary).forEach((group) => {\n      for (const xValue of Object.keys(aggregate)) {\n        if (aggregate[xValue].values[group] === undefined) {\n          if (addZeroes) aggregate[xValue].values[group] = 0\n          else continue\n        }\n        if (aggFun === 'mean') {\n          aggregate[xValue].values[group] =\n            Number(aggregate[xValue].values[group]) / groupSummary[group].n\n        }\n        if (aggFun === 'count_pct') {\n          aggregate[xValue].values[group] =\n            (100 * Number(aggregate[xValue].values[group])) / groupSummary[group].n\n        }\n        if (aggFun === 'pct') {\n          aggregate[xValue].values[group] =\n            (100 * Number(aggregate[xValue].values[group])) / groupSummary[group].sum\n        }\n      }\n    })\n  }\n\n  return aggregate\n}\n\nfunction prepareX (\n  table: PropsUITable & TableContext,\n  visualization: ChartVisualization\n): { groupBy: string[], xSortable: Record<string, string | number> | null } {\n  let groupBy = getTableColumn(table, visualization.group.column)\n  if (groupBy.length === 0) {\n    throw new Error(`X column ${table.id}.${visualization.group.column} not found`)\n  }\n  // let xSortable: Array<string | number> | null = null // separate variable allows using epoch time for sorting dates\n  let xSortable: Record<string, string | number> | null = null // map x values to sortable values\n\n  // ADD CODE TO TRANSFORM TO DATE, BUT THEN ALSO KEEP AN INDEX BASED ON THE DATE ORDER\n  if (visualization.group.dateFormat !== undefined) {\n    ;[groupBy, xSortable] = formatDate(groupBy, visualization.group.dateFormat)\n  }\n\n  if (visualization.group.levels !== undefined) {\n    xSortable = {}\n\n    for (let i = 0; i < visualization.group.levels.length; i++) {\n      const level = visualization.group.levels[i]\n      xSortable[level] = i\n    }\n  }\n\n  return { groupBy, xSortable }\n}\n\nexport interface PrepareAggregatedData {\n  xLabel: string\n  xValue: string\n  values: Record<string, number>\n  rowIds: Record<string, string[]>\n  sortBy: number | string\n  secondAxis?: boolean\n  tickerFormat?: TickerFormat\n}\n","import { getTableColumn, rescaleToRange, tokenize } from './util'\nimport { PropsUITable, TableContext } from '../../../../../types/elements'\nimport {\n  TextVisualizationData,\n  TextVisualization,\n  ScoredTerm\n} from '../../../../../types/visualizations'\n\ninterface VocabularyStats {\n  value: number\n  docFreq: number\n}\n\nexport async function prepareTextData (\n  table: PropsUITable & TableContext,\n  visualization: TextVisualization\n): Promise<TextVisualizationData> {\n  const visualizationData: TextVisualizationData = {\n    type: visualization.type,\n    topTerms: []\n  }\n\n  if (table.body.rows.length === 0) return visualizationData\n\n  const texts = getTableColumn(table, visualization.textColumn)\n  const values =\n    visualization.valueColumn != null ? getTableColumn(table, visualization.valueColumn) : null\n\n  const vocabulary = getVocabulary(texts, values, visualization)\n  visualizationData.topTerms = getTopTerms(vocabulary, texts.length, 200)\n\n  return visualizationData\n}\n\nfunction getVocabulary (\n  texts: string[],\n  values: string[] | null,\n  visualization: TextVisualization\n): Record<string, VocabularyStats> {\n  const vocabulary: Record<string, VocabularyStats> = {}\n\n  for (let i = 0; i < texts.length; i++) {\n    if (texts?.[i] == null) continue\n    const text = texts[i]\n    const tokens =\n      visualization.tokenize != null && visualization.tokenize ? tokenize(text) : [text]\n\n    const seen = new Set<string>()\n    for (const token of tokens) {\n      if (vocabulary[token] === undefined) vocabulary[token] = { value: 0, docFreq: 0 }\n      if (!seen.has(token)) {\n        vocabulary[token].docFreq += 1\n        seen.add(token)\n      }\n      const v = Number(values?.[i]) ?? 1\n      if (!isNaN(v)) vocabulary[token].value += v\n    }\n  }\n  return vocabulary\n}\n\nfunction getTopTerms (\n  vocabulary: Record<string, VocabularyStats>,\n  nDocs: number,\n  topTerms: number\n): ScoredTerm[] {\n  const words = Object.entries(vocabulary)\n    .map(([text, stats]) => {\n      const tf = Math.log(1 + stats.value)\n      const idf = Math.log(nDocs / stats.docFreq)\n      return { text, value: stats.value, importance: tf * idf }\n    })\n    .sort((a, b) => b.importance - a.importance)\n    .slice(0, topTerms)\n\n  const minImportance = Math.min(...words.map((w) => w.importance))\n  const maxImportance = Math.max(...words.map((w) => w.importance))\n\n  return words.map((w) => {\n    return {\n      text: w.text,\n      value: w.value,\n      importance: rescaleToRange(w.importance, minImportance, maxImportance, 0, 1)\n    }\n  })\n}\n","import { PropsUITable, TableContext, TableWithContext } from '../../../../types/elements'\nimport {\n  ChartVisualization,\n  TextVisualization,\n  VisualizationType,\n  VisualizationData\n} from '../../../../types/visualizations'\nimport { prepareChartData } from './visualizationDataFunctions/prepareChartData'\nimport { prepareTextData } from './visualizationDataFunctions/prepareTextData'\n\ninterface Input {\n  table: TableWithContext\n  visualization: VisualizationType\n}\n\nself.onmessage = (e: MessageEvent<Input>) => {\n  createVisualizationData(e.data.table, e.data.visualization)\n    .then((visualizationData) => {\n      self.postMessage({ status: 'success', visualizationData })\n    })\n    .catch((error) => {\n      console.error(error)\n      self.postMessage({ status: 'error', visualizationData: undefined })\n    })\n}\n\nasync function createVisualizationData (\n  table: PropsUITable & TableContext,\n  visualization: VisualizationType\n): Promise<VisualizationData> {\n  if (table === undefined || visualization === undefined) throw new Error('Table and visualization are required')\n\n  if (['line', 'bar', 'area'].includes(visualization.type)) { return await prepareChartData(table, visualization as ChartVisualization) }\n\n  if (['wordcloud'].includes(visualization.type)) { return await prepareTextData(table, visualization as TextVisualization) }\n\n  throw new Error(`Visualization type ${visualization.type} not supported`)\n}\n"],"names":["autoFormatDate","dateNumbers","minValues","minTime","Math","min","maxTime","max","autoFormat","createSortable","domain","interval","formatter","sortable","intervalNumber","includes","i","datestring","Date","undefined","tokenize","text","split","filter","token","test","getTableColumn","table","column","columnIndex","head","cells","findIndex","cell","Error","id","body","rows","map","row","rescaleToRange","value","newMin","newMax","async","prepareChartData","visualization","length","emptyVisualizationData","aggregate","groupBy","xSortable","group","dateFormat","dateString","format","formattedDate","date","getTime","toISOString","getFullYear","toString","year","quarter","floor","getMonth","month","toLocaleString","day","getDate","Intl","DateTimeFormat","weekday","hour","hour12","sortableDate","formatDate","levels","prepareX","rowIds","xLabel","label","values","aggFun","tickerFormat","yValues","yGroup","group_by","addZeroes","groupSummary","uniqueValue","sortby","Object","entries","sortBy","xValue","secondAxis","range","Number","yValue","n","sum","String","push","keys","forEach","aggregateData","visualizationData","aggdata","yKeys","data","sort","a","b","d","key","round","__rowIds","__sortBy","createVisualizationData","type","xKey","prepareTextData","topTerms","texts","textColumn","vocabulary","tokens","seen","Set","docFreq","has","add","v","isNaN","getVocabulary","valueColumn","nDocs","words","stats","tf","log","idf","importance","slice","minImportance","w","maxImportance","getTopTerms","self","onmessage","e","then","postMessage","status","catch","error","console"],"sourceRoot":""}