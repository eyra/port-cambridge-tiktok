{"version":3,"file":"static/js/448.94097709.chunk.js","mappings":"mBAoFA,SAASA,EAAgBC,EAAuBC,GAC9C,MAAOC,EAASC,GAAWC,EAAUJ,GAErC,IAAIK,EAAyB,OAM7B,OALIF,EAAUD,EAAU,MAAsBD,IAAWI,EAAa,OAClEF,EAAUD,EAAU,OAA2BD,IAAWI,EAAa,SACvEF,EAAUD,EAAU,OAA+BD,IAAWI,EAAa,WAC3EF,EAAUD,EAAU,QAA4BD,IAAWI,EAAa,QAErEA,CACR,CAED,SAASC,EACPC,EACAC,EACAC,GAIA,MAAMC,EAAmC,CAAC,GACnCR,EAASC,GAAWI,EAK3B,IAAII,EAAyB,EAO7B,GANiB,SAAbH,IAAqBG,EAAiB,UACzB,YAAbH,IAAwBG,EAAiB,SACzC,CAAC,QAAS,eAAeC,SAASJ,KAAWG,EAAiB,SAC9D,CAAC,MAAO,iBAAiBC,SAASJ,KAAWG,EAAiB,OAC9D,CAAC,OAAQ,cAAcC,SAASJ,KAAWG,EAAiB,MAE5DA,EAAiB,EACnB,IAAK,IAAIE,EAAIX,EAASW,GAAKV,EAASU,GAAKF,EAAgB,CACvD,MACMG,EAAaL,EADN,IAAIM,KAAKF,SAEOG,IAAzBN,EAASI,KACbJ,EAASI,GAAcD,EACxB,CAGH,OAAOH,CACR,CAED,SAASN,EAAWa,GAClB,IAAIC,EAAMD,EAAQ,GACdE,EAAMF,EAAQ,GAKlB,OAJAA,EAAQG,SAASC,IACXA,EAAKH,IAAKA,EAAMG,GAChBA,EAAKF,IAAKA,EAAME,EAAN,IAET,CAACH,EAAKC,EACd,CAEM,SAASG,EAAUC,GAExB,OADeA,EAAKC,MAAM,KACZC,QAAQC,GAAU,WAAWC,KAAKD,IACjD,CAEM,SAASE,EAAgBC,EAAoCC,GAClE,MAAMC,EAAcF,EAAMG,KAAKC,MAAMC,WAAWC,GAASA,EAAKZ,OAASO,IACvE,GAAIC,EAAc,EAAG,MAAM,IAAIK,MAAJ,iBAAoBP,EAAMQ,GAA1B,YAAgCP,EAAhC,eAC3B,OAAOD,EAAMS,KAAKC,KAAKC,KAAKC,GAAQA,EAAIR,MAAMF,GAAaR,MAC5D,CAEM,SAASmB,EACdC,EACAzB,EACAC,EACAyB,EACAC,GAEA,IAAIC,GAAUH,EAAQzB,IAAQC,EAAMD,GAEpC,OADA4B,EAASC,MAAMD,GAAU,EAAIA,EACtBA,GAAUD,EAASD,GAAUA,CACrC,CCvJMI,eAAeC,EACpBpB,EACAqB,GAEA,GAA+B,IAA3BrB,EAAMS,KAAKC,KAAKY,OAAc,OAAOC,EAAuBF,GAEhE,MAAMG,EAoDR,SACExB,EACAqB,GAEA,MAAMG,EAAmD,CAAC,GAEpD,QAAEC,EAAF,UAAWC,GAmHnB,SACE1B,EACAqB,GAEA,IAAII,EAAU1B,EAAeC,EAAOqB,EAAcM,MAAM1B,QACxD,GAAuB,IAAnBwB,EAAQH,OACV,MAAM,IAAIf,MAAJ,mBAAsBP,EAAMQ,GAA5B,YAAkCa,EAAcM,MAAM1B,OAAtD,eAGR,IAAIyB,EAAoD,UAGjBvC,IAAnCkC,EAAcM,MAAMC,cACpBH,EAASC,GDrMR,SACLG,EACAC,GAE4C,IAD5C1D,EAC2C,uDADvB,GAEhB2D,EAA0BF,EAC9B,MAAM1D,EAAc0D,EAAWlB,KAAKqB,GAAS,IAAI9C,KAAK8C,GAAMC,YAC5D,IAAIvD,EAAkC,KAClCE,EAAqCoD,GAASA,EAAKE,cAExC,SAAXJ,IAAmBA,EAAS5D,EAAeC,EAAaC,IAE7C,SAAX0D,IAAmBlD,EAAaoD,GAASA,EAAKG,cAAcC,YAEjD,YAAXN,IACFlD,EAAaoD,IACX,MAAMK,EAAOL,EAAKG,cAAcC,WAC1BE,EAAUC,KAAKC,MAAMR,EAAKS,WAAa,GAAK,EAClD,MAAM,GAAN,OAAUJ,EAAV,aAAmBC,EAAnB,GAIW,UAAXR,IACFlD,EAAaoD,IACX,MAAMK,EAAOL,EAAKG,cAAcC,WAC1BM,EAAQV,EAAKW,eAAe,UAAW,CAAED,MAAO,UACtD,MAAM,GAAN,OAAUL,EAAV,YAAkBK,EAAlB,GAIW,QAAXZ,IACFlD,EAAaoD,IACX,MAAMK,EAAOL,EAAKG,cAAcC,WAC1BM,EAAQV,EAAKW,eAAe,UAAW,CAAED,MAAO,UAChDE,EAAMZ,EAAKa,UAAUT,WAC3B,MAAM,GAAN,OAAUC,EAAV,YAAkBK,EAAlB,YAA2BE,EAA3B,GAIW,SAAXd,IACFlD,EAAaoD,IACX,MAAMK,EAAOL,EAAKG,cAAcC,WAC1BM,EAAQV,EAAKW,eAAe,UAAW,CAAED,MAAO,UAChDE,EAAMZ,EAAKa,UAAUT,WACrBU,EAAOd,EAAKE,cAAcvC,MAAM,KAAK,GAAGA,MAAM,KAAK,GACzD,MAAM,GAAN,OAAU0C,EAAV,YAAkBK,EAAlB,YAA2BE,EAA3B,YAAkCE,EAAlC,SAIW,gBAAXhB,IACFlD,EAAaoD,GACW,IAAIe,KAAKC,eAAe,UAAW,CAAEN,MAAO,SAC7CZ,OAAOE,GAG9BtD,EAAS,CAAC,IAAIQ,KAAK,cAAc+C,UAAW,IAAI/C,KAAK,cAAc+C,YAEtD,kBAAXH,IACFlD,EAAaoD,GACW,IAAIe,KAAKC,eAAe,UAAW,CAAEC,QAAS,SAC/CnB,OAAOE,GAG9BtD,EAAS,CAAC,IAAIQ,KAAK,cAAc+C,UAAW,IAAI/C,KAAK,cAAc+C,YAEtD,eAAXH,IACFlD,EAAaoD,GACW,IAAIe,KAAKC,eAAe,UAAW,CAAEF,KAAM,UAAWI,QAAQ,IAC/DpB,OAAOE,GAG9BtD,EAAS,CAAC,IAAIQ,KAAK,cAAc+C,UAAW,IAAI/C,KAAK,cAAc+C,YAGrEF,EAAgB5D,EAAYwC,KAAKqB,GAASpD,EAAU,IAAIM,KAAK8C,MAC/C,MAAVtD,IAAgBA,EAASH,EAAUJ,IACvC,MAAMgF,EAA8C1E,EAAeC,EAAQoD,EAAQlD,GAEnF,MAAO,CAACmD,EAAeoB,EACxB,CCsH2BC,CAAW3B,EAASJ,EAAcM,MAAMC,aAGlE,QAAmCzC,IAA/BkC,EAAcM,MAAM0B,OAAsB,CAC5C3B,EAAY,CAAC,EAEb,IAAK,IAAI1C,EAAI,EAAGA,EAAIqC,EAAcM,MAAM0B,OAAO/B,OAAQtC,IAAK,CAE1D0C,EADcL,EAAcM,MAAM0B,OAAOrE,IACtBA,CACpB,CACF,CAED,MAAO,CAAEyC,UAASC,YACnB,CA7IgC4B,CAAStD,EAAOqB,GACzCkC,EAASvD,EAAMS,KAAKC,KAAKC,KAAKC,GAAQA,EAAIJ,KAC1CgD,OAC0BrE,IAA9BkC,EAAcM,MAAM8B,MAAsBpC,EAAcM,MAAM8B,MAAQpC,EAAcM,MAAM1B,OAG5F,GADqBoB,EAAcqC,OAAOC,MAAM7C,IAA8B,IAApBA,EAAM8C,aAC/B,MAAblC,EAClB,IAAK,MAAOmC,EAAaC,KAAWC,OAAOC,QAAQtC,GACjDF,EAAUqC,GAAe,CACvBI,OAAQH,EACRP,OAAQ,CAAC,EACTC,SACAU,OAAQL,EACRH,OAAQ,CAAC,EACTS,YAAY,EACZC,aAAc,WAKpB,IAAK,MAAMtD,KAASO,EAAcqC,OAAQ,CAAC,IAAD,EAGxC,MAAMW,OAA6BlF,IAApB2B,EAAMU,UAA0BV,EAAMU,UAAY,QACjE,IAAI4C,EAA6B,UAClB,QAAXC,GAA+B,cAAXA,IAAwBD,EAAe,WAE/D,MAAME,EAAUvE,EAAeC,EAAOc,EAAMb,QAC5C,GAAuB,IAAnBqE,EAAQhD,OAAc,MAAM,IAAIf,MAAJ,mBAAsBP,EAAMQ,GAA5B,YAAkCM,EAAMb,OAAxC,eAGhC,MAAMsE,OAA4BpF,IAAnB2B,EAAM0D,SAAyBzE,EAAeC,EAAOc,EAAM0D,UAAY,KAGhFZ,EAAS,UAAG9C,EAAM8C,iBAAT,SACTa,EAA2D,CAAC,EAElE,IAAK,IAAIzF,EAAI,EAAGA,EAAIuE,EAAOjC,OAAQtC,IAAK,CAAC,IAAD,EAEtC,MAAMkF,EAASzC,EAAQzC,GAEvB,QAAkCG,IAA9BkC,EAAcM,MAAM+C,QAEpBC,OAAOT,GAAU7C,EAAcM,MAAM+C,MAAM,IAC3CC,OAAOT,GAAU7C,EAAcM,MAAM+C,MAAM,IAE3C,SAWJ,MAAME,EAASN,EAAQtF,GACjByE,OAAwBtE,IAAhB2B,EAAM2C,MAAsB3C,EAAM2C,MAAQ3C,EAAMb,OACxD0B,EAAkB,MAAV4C,EAAiBA,EAAOvF,GAAKyE,EAErCQ,EAAsB,MAAbvC,EAAoBA,EAAUwC,GAAUzC,EAAQzC,GAuBC,IAAD,EAA/D,QApB4BG,IAAxBsF,EAAa9C,KAAsB8C,EAAa9C,GAAS,CAAEkD,EAAG,EAAGC,IAAK,IAC3D,cAAXT,GAAqC,SAAXA,IAAmBI,EAAa9C,GAAOkD,GAAK,GAC3D,QAAXR,IAAkBI,EAAa9C,GAAOmD,KAApB,UAA2BH,OAAOC,UAAlC,QAA6C,QAEzCzF,IAAtBqC,EAAU0C,KACZ1C,EAAU0C,GAAU,CAClBD,OAAQA,EACRV,OAAQ,CAAC,EACTC,SACAU,OAAQa,OAAOb,GACfR,OAAQ,CAAC,EACTS,WAAYrD,EAAMqD,WAClBC,sBAGoCjF,IAApCqC,EAAU0C,GAAQX,OAAO5B,KAAsBH,EAAU0C,GAAQX,OAAO5B,GAAS,IACrFH,EAAU0C,GAAQX,OAAO5B,GAAOqD,KAAKzB,EAAOvE,SAEJG,IAApCqC,EAAU0C,GAAQR,OAAO/B,KAAsBH,EAAU0C,GAAQR,OAAO/B,GAAS,GACtE,UAAX0C,GAAiC,cAAXA,IAAwB7C,EAAU0C,GAAQR,OAAO/B,IAAU,GACtE,QAAX0C,GAA+B,SAAXA,GAAgC,QAAXA,EAC3C7C,EAAU0C,GAAQR,OAAO/B,IAAzB,UAAmCgD,OAAOC,UAA1C,QAAqD,CAExD,CAGDb,OAAOkB,KAAKR,GAAclF,SAASoC,IACjC,IAAK,MAAMuC,KAAUH,OAAOkB,KAAKzD,GAAY,CAC3C,QAAwCrC,IAApCqC,EAAU0C,GAAQR,OAAO/B,GAAsB,CACjD,IAAIiC,EACC,SADUpC,EAAU0C,GAAQR,OAAO/B,GAAS,CAElD,CACc,SAAX0C,IACF7C,EAAU0C,GAAQR,OAAO/B,GACvBgD,OAAOnD,EAAU0C,GAAQR,OAAO/B,IAAU8C,EAAa9C,GAAOkD,GAEnD,cAAXR,IACF7C,EAAU0C,GAAQR,OAAO/B,GACtB,IAAMgD,OAAOnD,EAAU0C,GAAQR,OAAO/B,IAAW8C,EAAa9C,GAAOkD,GAE3D,QAAXR,IACF7C,EAAU0C,GAAQR,OAAO/B,GACtB,IAAMgD,OAAOnD,EAAU0C,GAAQR,OAAO/B,IAAW8C,EAAa9C,GAAOmD,IAE3E,IAEJ,CAED,OAAOtD,CACR,CA3KmB0D,CAAclF,EAAOqB,GACvC,OAGF,SACEA,EACAG,GAEA,MAAM2D,EAAoB5D,EAAuBF,GAEjD,IAAK,MAAM+D,KAAWrB,OAAOL,OAAOlC,GAClC,IAAK,MAAMG,KAASoC,OAAOkB,KAAKG,EAAQ1B,aACCvE,IAAnCgG,EAAkBE,MAAM1D,KAC1BwD,EAAkBE,MAAM1D,GAAS,CAC/B8B,MAAO9B,EACPwC,WAAYiB,EAAQjB,WACpBC,aAAcgB,EAAQhB,eAmB9B,OAbAe,EAAkBG,KAAOvB,OAAOL,OAAOlC,GACpC+D,MAAK,CAACC,EAAQC,IAAYD,EAAEvB,OAASwB,EAAExB,QAAU,EAAIwB,EAAExB,OAASuB,EAAEvB,OAAS,EAAI,IAC/EtD,KAAK+E,IACJ,IAAK,MAAMC,KAAO5B,OAAOkB,KAAKS,EAAEhC,QAASgC,EAAEhC,OAAOiC,GAAOpD,KAAKqD,MAAsB,IAAhBF,EAAEhC,OAAOiC,IAAc,IAE3F,MAAO,IACFD,EAAEhC,OACL,CAACgC,EAAElC,QAASkC,EAAExB,OACd2B,SAAUH,EAAEnC,OACZuC,SAAUJ,EAAEzB,OAJd,IAQGkB,CACR,CAnCQY,CAAwB1E,EAAeG,EAC/C,CAoCD,SAASD,EAAwBF,GAC/B,MAAO,CACL2E,KAAM3E,EAAc2E,KACpBC,KAAM,CACJxC,WACgCtE,IAA9BkC,EAAcM,MAAM8B,MAChBpC,EAAcM,MAAM8B,MACpBpC,EAAcM,MAAM1B,QAE5BoF,MAAO,CAAC,EACRC,KAAM,GAET,CCnDMnE,eAAe+E,EACpBlG,EACAqB,GAEA,MAAM8D,EAA2C,CAC/Ca,KAAM3E,EAAc2E,KACpBG,SAAU,IAGZ,GAA+B,IAA3BnG,EAAMS,KAAKC,KAAKY,OAAc,OAAO6D,EAEzC,MAAMiB,EAAQrG,EAAeC,EAAOqB,EAAcgF,YAI5CC,EAMR,SACEF,EACA1C,EACArC,GAEA,MAAMiF,EAA8C,CAAC,EAErD,IAAK,IAAItH,EAAI,EAAGA,EAAIoH,EAAM9E,OAAQtC,IAAK,CACrC,GAAkB,OAAT,OAALoH,QAAK,IAALA,OAAA,EAAAA,EAAQpH,IAAY,SACxB,MAAMU,EAAO0G,EAAMpH,GACbuH,EACsB,MAA1BlF,EAAc5B,UAAoB4B,EAAc5B,SAAWA,EAASC,GAAQ,CAACA,GAEzE8G,EAAO,IAAIC,IACjB,IAAK,MAAM5G,KAAS0G,EAAQ,CAAC,IAAD,OACApH,IAAtBmH,EAAWzG,KAAsByG,EAAWzG,GAAS,CAAEiB,MAAO,EAAG4F,QAAS,IACzEF,EAAKG,IAAI9G,KACZyG,EAAWzG,GAAO6G,SAAW,EAC7BF,EAAKI,IAAI/G,IAEX,MAAMgH,EAAC,UAAGlC,OAAM,OAACjB,QAAD,IAACA,OAAD,EAACA,EAAS1E,WAAnB,QAA0B,EAC5BkC,MAAM2F,KAAIP,EAAWzG,GAAOiB,OAAS+F,EAC3C,CACF,CACD,OAAOP,CACR,CA/BoBQ,CAAcV,EAFF,MAA7B/E,EAAc0F,YAAsBhH,EAAeC,EAAOqB,EAAc0F,aAAe,KAEzC1F,GAGhD,OAFA8D,EAAkBgB,SAgCpB,SACEG,EACAU,EACAb,GAEA,MAAMc,EAAQlD,OAAOC,QAAQsC,GAC1B3F,KAAI,IAAoB,IAAlBjB,EAAMwH,GAAW,EACtB,MAAMC,EAAK5E,KAAK6E,IAAI,EAAIF,EAAMpG,OACxBuG,EAAM9E,KAAK6E,IAAIJ,EAAQE,EAAMR,SACnC,MAAO,CAAEhH,OAAMoB,MAAOoG,EAAMpG,MAAOwG,WAAYH,EAAKE,EAApD,IAED9B,MAAK,CAACC,EAAGC,IAAMA,EAAE6B,WAAa9B,EAAE8B,aAChCC,MAAM,EAAGpB,GAENqB,EAAgBjF,KAAKlD,OAAO4H,EAAMtG,KAAK8G,GAAMA,EAAEH,cAC/CI,EAAgBnF,KAAKjD,OAAO2H,EAAMtG,KAAK8G,GAAMA,EAAEH,cAErD,OAAOL,EAAMtG,KAAK8G,IACT,CACL/H,KAAM+H,EAAE/H,KACRoB,MAAO2G,EAAE3G,MACTwG,WAAYzG,EAAe4G,EAAEH,WAAYE,EAAeE,EAAe,EAAG,MAG/E,CAxD8BC,CAAYrB,EAAYF,EAAM9E,OAAQ,KAE5D6D,CACR,CCjBDyC,KAAKC,UAAaC,KAWlB3G,eACEnB,EACAqB,GAEA,QAAclC,IAAVa,QAAyCb,IAAlBkC,EAA6B,MAAM,IAAId,MAAM,wCAExE,GAAI,CAAC,OAAQ,MAAO,QAAQxB,SAASsC,EAAc2E,MAAS,aAAa5E,EAAiBpB,EAAOqB,GAEjG,GAAI,CAAC,aAAatC,SAASsC,EAAc2E,MAAS,aAAaE,EAAgBlG,EAAOqB,GAEtF,MAAM,IAAId,MAAJ,6BAAgCc,EAAc2E,KAA9C,kBACP,EArBCD,CAAwB+B,EAAExC,KAAKtF,MAAO8H,EAAExC,KAAKjE,eAC1C0G,MAAM5C,IACLyC,KAAKI,YAAY,CAAEC,OAAQ,UAAW9C,qBAAtC,IAED+C,OAAOC,IACNC,QAAQD,MAAMA,GACdP,KAAKI,YAAY,CAAEC,OAAQ,QAAS9C,uBAAmBhG,GAAvD,GANJ,C","sources":["framework/visualisation/react/ui/workers/visualizationDataFunctions/util.ts","framework/visualisation/react/ui/workers/visualizationDataFunctions/prepareChartData.ts","framework/visualisation/react/ui/workers/visualizationDataFunctions/prepareTextData.ts","framework/visualisation/react/ui/workers/visualizationDataWorker.ts"],"sourcesContent":["import { PropsUITable, TableContext } from '../../../../../types/elements'\nimport { DateFormat } from '../../../../../types/visualizations'\n\nexport function formatDate (\n  dateString: string[],\n  format: DateFormat,\n  minValues: number = 10\n): [string[], Record<string, number> | null] {\n  let formattedDate: string[] = dateString\n  const dateNumbers = dateString.map((date) => new Date(date).getTime())\n  let domain: [number, number] | null = null\n  let formatter: (date: Date) => string = (date) => date.toISOString()\n\n  if (format === 'auto') format = autoFormatDate(dateNumbers, minValues)\n\n  if (format === 'year') formatter = (date) => date.getFullYear().toString()\n\n  if (format === 'quarter') {\n    formatter = (date) => {\n      const year = date.getFullYear().toString()\n      const quarter = Math.floor(date.getMonth() / 3) + 1\n      return `${year}-Q${quarter}`\n    }\n  }\n\n  if (format === 'month') {\n    formatter = (date) => {\n      const year = date.getFullYear().toString()\n      const month = date.toLocaleString('default', { month: 'short' })\n      return `${year}-${month}`\n    }\n  }\n\n  if (format === 'day') {\n    formatter = (date) => {\n      const year = date.getFullYear().toString()\n      const month = date.toLocaleString('default', { month: 'short' })\n      const day = date.getDate().toString()\n      return `${year}-${month}-${day}`\n    }\n  }\n\n  if (format === 'hour') {\n    formatter = (date) => {\n      const year = date.getFullYear().toString()\n      const month = date.toLocaleString('default', { month: 'short' })\n      const day = date.getDate().toString()\n      const hour = date.toISOString().split('T')[1].split(':')[0]\n      return `${year}-${month}-${day} ${hour}:00`\n    }\n  }\n\n  if (format === 'month_cycle') {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat('default', { month: 'long' })\n      return intlFormatter.format(date)\n    }\n    // can be any year, starting at january\n    domain = [new Date('2000-01-01').getTime(), new Date('2001-01-01').getTime()]\n  }\n  if (format === 'weekday_cycle') {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat('default', { weekday: 'long' })\n      return intlFormatter.format(date)\n    }\n    // can be any full week, starting at monday\n    domain = [new Date('2023-11-06').getTime(), new Date('2023-11-13').getTime()]\n  }\n  if (format === 'hour_cycle') {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat('default', { hour: 'numeric', hour12: false })\n      return intlFormatter.format(date)\n    }\n    // can be any day, starting at midnight\n    domain = [new Date('2000-01-01').getTime(), new Date('2000-01-02').getTime()]\n  }\n\n  formattedDate = dateNumbers.map((date) => formatter(new Date(date)))\n  if (domain == null) domain = getDomain(dateNumbers)\n  const sortableDate: Record<string, number> | null = createSortable(domain, format, formatter)\n\n  return [formattedDate, sortableDate]\n}\n\nfunction autoFormatDate (dateNumbers: number[], minValues: number): DateFormat {\n  const [minTime, maxTime] = getDomain(dateNumbers)\n\n  let autoFormat: DateFormat = 'hour'\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * minValues) autoFormat = 'day'\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 30 * minValues) autoFormat = 'month'\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 30 * 3 * minValues) autoFormat = 'quarter'\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 365 * minValues) autoFormat = 'year'\n\n  return autoFormat\n}\n\nfunction createSortable (\n  domain: [number, number],\n  interval: string,\n  formatter: (date: Date) => string\n): Record<string, number> | null {\n  // creates a map of datestrings to sortby numbers. Also includes intervalls, so that\n  // addZeroes can be used.\n  const sortable: Record<string, number> = {}\n  const [minTime, maxTime] = domain\n\n  // intervalnumbers don't need to be exact. Just small enough that they never\n  // skip over an interval (e.g., month should be shortest possible month).\n  // Duplicate dates are ignored in set\n  let intervalNumber: number = 0\n  if (interval === 'year') intervalNumber = 1000 * 60 * 60 * 24 * 364\n  if (interval === 'quarter') intervalNumber = 1000 * 60 * 60 * 24 * 28 * 3\n  if (['month', 'month_cycle'].includes(interval)) intervalNumber = 1000 * 60 * 60 * 24 * 28\n  if (['day', 'weekday_cycle'].includes(interval)) intervalNumber = 1000 * 60 * 60 * 24\n  if (['hour', 'hour_cycle'].includes(interval)) intervalNumber = 1000 * 60 * 60\n\n  if (intervalNumber > 0) {\n    for (let i = minTime; i <= maxTime; i += intervalNumber) {\n      const date = new Date(i)\n      const datestring = formatter(date)\n      if (sortable[datestring] !== undefined) continue\n      sortable[datestring] = i\n    }\n  }\n\n  return sortable\n}\n\nfunction getDomain (numbers: number[]): [number, number] {\n  let min = numbers[0]\n  let max = numbers[0]\n  numbers.forEach((nr) => {\n    if (nr < min) min = nr\n    if (nr > max) max = nr\n  })\n  return [min, max]\n}\n\nexport function tokenize (text: string): string[] {\n  const tokens = text.split(' ')\n  return tokens.filter((token) => /\\p{L}/giu.test(token)) // only tokens with word characters\n}\n\nexport function getTableColumn (table: PropsUITable & TableContext, column: string): string[] {\n  const columnIndex = table.head.cells.findIndex((cell) => cell.text === column)\n  if (columnIndex < 0) throw new Error(`column ${table.id}.${column} not found`)\n  return table.body.rows.map((row) => row.cells[columnIndex].text)\n}\n\nexport function rescaleToRange (\n  value: number,\n  min: number,\n  max: number,\n  newMin: number,\n  newMax: number\n): number {\n  let scaled = (value - min) / (max - min)\n  scaled = isNaN(scaled) ? 0 : scaled\n  return scaled * (newMax - newMin) + newMin\n}\n\nexport function extractUrlDomain (x: string): string {\n  let domain\n  try {\n    const url = new URL(x)\n    domain = url.hostname.replace(/^www\\./, '').replace(/^m\\./, '')\n  } catch (_) {\n    domain = x\n  }\n  return domain.trim()\n}\n","import { formatDate, getTableColumn } from './util'\nimport { PropsUITable, TableContext } from '../../../../../types/elements'\nimport {\n  TickerFormat,\n  ChartVisualizationData,\n  ChartVisualization\n} from '../../../../../types/visualizations'\n\nexport async function prepareChartData (\n  table: PropsUITable & TableContext,\n  visualization: ChartVisualization\n): Promise<ChartVisualizationData> {\n  if (table.body.rows.length === 0) return emptyVisualizationData(visualization)\n\n  const aggregate = aggregateData(table, visualization)\n  return createVisualizationData(visualization, aggregate)\n}\n\nfunction createVisualizationData (\n  visualization: ChartVisualization,\n  aggregate: Record<string, PrepareAggregatedData>\n): ChartVisualizationData {\n  const visualizationData = emptyVisualizationData(visualization)\n\n  for (const aggdata of Object.values(aggregate)) {\n    for (const group of Object.keys(aggdata.values)) {\n      if (visualizationData.yKeys[group] === undefined) {\n        visualizationData.yKeys[group] = {\n          label: group,\n          secondAxis: aggdata.secondAxis,\n          tickerFormat: aggdata.tickerFormat\n        }\n      }\n    }\n  }\n\n  visualizationData.data = Object.values(aggregate)\n    .sort((a: any, b: any) => (a.sortBy < b.sortBy ? -1 : b.sortBy < a.sortBy ? 1 : 0))\n    .map((d) => {\n      for (const key of Object.keys(d.values)) d.values[key] = Math.round(d.values[key] * 100) / 100\n\n      return {\n        ...d.values,\n        [d.xLabel]: d.xValue,\n        __rowIds: d.rowIds,\n        __sortBy: d.sortBy\n      }\n    })\n\n  return visualizationData\n}\n\nfunction emptyVisualizationData (visualization: ChartVisualization): ChartVisualizationData {\n  return {\n    type: visualization.type,\n    xKey: {\n      label:\n        visualization.group.label !== undefined\n          ? visualization.group.label\n          : visualization.group.column\n    },\n    yKeys: {},\n    data: []\n  }\n}\n\nfunction aggregateData (\n  table: PropsUITable & TableContext,\n  visualization: ChartVisualization\n): Record<string, PrepareAggregatedData> {\n  const aggregate: Record<string, PrepareAggregatedData> = {}\n\n  const { groupBy, xSortable } = prepareX(table, visualization)\n  const rowIds = table.body.rows.map((row) => row.id)\n  const xLabel =\n    visualization.group.label !== undefined ? visualization.group.label : visualization.group.column\n\n  const anyAddZeroes = visualization.values.some((value) => value.addZeroes === true)\n  if (anyAddZeroes && xSortable != null) {\n    for (const [uniqueValue, sortby] of Object.entries(xSortable)) {\n      aggregate[uniqueValue] = {\n        sortBy: sortby,\n        rowIds: {},\n        xLabel,\n        xValue: uniqueValue,\n        values: {},\n        secondAxis: false,\n        tickerFormat: 'default'\n      }\n    }\n  }\n\n  for (const value of visualization.values) {\n    // loop over all y values\n\n    const aggFun = value.aggregate !== undefined ? value.aggregate : 'count'\n    let tickerFormat: TickerFormat = 'default'\n    if (aggFun === 'pct' || aggFun === 'count_pct') tickerFormat = 'percent'\n\n    const yValues = getTableColumn(table, value.column)\n    if (yValues.length === 0) throw new Error(`Y column ${table.id}.${value.column} not found`)\n\n    // If group_by column is specified, the columns in the aggregated data will be the unique group_by columns\n    const yGroup = value.group_by !== undefined ? getTableColumn(table, value.group_by) : null\n\n    // if missing values should be treated as zero, we need to add the missing values after knowing all groups\n    const addZeroes = value.addZeroes ?? false\n    const groupSummary: Record<string, { n: number, sum: number }> = {}\n\n    for (let i = 0; i < rowIds.length; i++) {\n      // loop over rows of table\n      const xValue = groupBy[i]\n\n      if (visualization.group.range !== undefined) {\n        if (\n          Number(xValue) < visualization.group.range[0] ||\n          Number(xValue) > visualization.group.range[1]\n        ) {\n          continue\n        }\n      }\n\n      // SHOULD GROUP BE IGNORED IF NOT IN group.levels? MAYBE NOT, BECAUSE\n      // THIS COULD HARM INFORMED CONSENT IF THE RESEARCHER IS UNAWARE OF CERTAIN GROUPS\n      // if (visualization.group.levels !== undefined) {\n      //   // formatLevels has xSortable < 0 if no match with levels\n      //   if (xSortable !== null && xSortable[i] < 0) continue\n      // }\n\n      const yValue = yValues[i]\n      const label = value.label !== undefined ? value.label : value.column\n      const group = yGroup != null ? yGroup[i] : label\n\n      const sortBy = xSortable != null ? xSortable[xValue] : groupBy[i]\n\n      // calculate group summary statistics. This is used for the mean, pct and count_pct aggregations\n      if (groupSummary[group] === undefined) groupSummary[group] = { n: 0, sum: 0 }\n      if (aggFun === 'count_pct' || aggFun === 'mean') groupSummary[group].n += 1\n      if (aggFun === 'pct') groupSummary[group].sum += Number(yValue) ?? 0\n\n      if (aggregate[xValue] === undefined) {\n        aggregate[xValue] = {\n          sortBy: sortBy,\n          rowIds: {},\n          xLabel,\n          xValue: String(xValue),\n          values: {},\n          secondAxis: value.secondAxis,\n          tickerFormat\n        }\n      }\n      if (aggregate[xValue].rowIds[group] === undefined) aggregate[xValue].rowIds[group] = []\n      aggregate[xValue].rowIds[group].push(rowIds[i])\n\n      if (aggregate[xValue].values[group] === undefined) aggregate[xValue].values[group] = 0\n      if (aggFun === 'count' || aggFun === 'count_pct') aggregate[xValue].values[group] += 1\n      if (aggFun === 'sum' || aggFun === 'mean' || aggFun === 'pct') {\n        aggregate[xValue].values[group] += Number(yValue) ?? 0\n      }\n    }\n\n    // use groupSummary to calculate the mean, pct and count_pct aggregations\n    Object.keys(groupSummary).forEach((group) => {\n      for (const xValue of Object.keys(aggregate)) {\n        if (aggregate[xValue].values[group] === undefined) {\n          if (addZeroes) aggregate[xValue].values[group] = 0\n          else continue\n        }\n        if (aggFun === 'mean') {\n          aggregate[xValue].values[group] =\n            Number(aggregate[xValue].values[group]) / groupSummary[group].n\n        }\n        if (aggFun === 'count_pct') {\n          aggregate[xValue].values[group] =\n            (100 * Number(aggregate[xValue].values[group])) / groupSummary[group].n\n        }\n        if (aggFun === 'pct') {\n          aggregate[xValue].values[group] =\n            (100 * Number(aggregate[xValue].values[group])) / groupSummary[group].sum\n        }\n      }\n    })\n  }\n\n  return aggregate\n}\n\nfunction prepareX (\n  table: PropsUITable & TableContext,\n  visualization: ChartVisualization\n): { groupBy: string[], xSortable: Record<string, string | number> | null } {\n  let groupBy = getTableColumn(table, visualization.group.column)\n  if (groupBy.length === 0) {\n    throw new Error(`X column ${table.id}.${visualization.group.column} not found`)\n  }\n  // let xSortable: Array<string | number> | null = null // separate variable allows using epoch time for sorting dates\n  let xSortable: Record<string, string | number> | null = null // map x values to sortable values\n\n  // ADD CODE TO TRANSFORM TO DATE, BUT THEN ALSO KEEP AN INDEX BASED ON THE DATE ORDER\n  if (visualization.group.dateFormat !== undefined) {\n    ;[groupBy, xSortable] = formatDate(groupBy, visualization.group.dateFormat)\n  }\n\n  if (visualization.group.levels !== undefined) {\n    xSortable = {}\n\n    for (let i = 0; i < visualization.group.levels.length; i++) {\n      const level = visualization.group.levels[i]\n      xSortable[level] = i\n    }\n  }\n\n  return { groupBy, xSortable }\n}\n\nexport interface PrepareAggregatedData {\n  xLabel: string\n  xValue: string\n  values: Record<string, number>\n  rowIds: Record<string, string[]>\n  sortBy: number | string\n  secondAxis?: boolean\n  tickerFormat?: TickerFormat\n}\n","import { getTableColumn, rescaleToRange, tokenize } from './util'\nimport { PropsUITable, TableContext } from '../../../../../types/elements'\nimport {\n  TextVisualizationData,\n  TextVisualization,\n  ScoredTerm\n} from '../../../../../types/visualizations'\n\ninterface VocabularyStats {\n  value: number\n  docFreq: number\n}\n\nexport async function prepareTextData (\n  table: PropsUITable & TableContext,\n  visualization: TextVisualization\n): Promise<TextVisualizationData> {\n  const visualizationData: TextVisualizationData = {\n    type: visualization.type,\n    topTerms: []\n  }\n\n  if (table.body.rows.length === 0) return visualizationData\n\n  const texts = getTableColumn(table, visualization.textColumn)\n  const values =\n    visualization.valueColumn != null ? getTableColumn(table, visualization.valueColumn) : null\n\n  const vocabulary = getVocabulary(texts, values, visualization)\n  visualizationData.topTerms = getTopTerms(vocabulary, texts.length, 200)\n\n  return visualizationData\n}\n\nfunction getVocabulary (\n  texts: string[],\n  values: string[] | null,\n  visualization: TextVisualization\n): Record<string, VocabularyStats> {\n  const vocabulary: Record<string, VocabularyStats> = {}\n\n  for (let i = 0; i < texts.length; i++) {\n    if (texts?.[i] == null) continue\n    const text = texts[i]\n    const tokens =\n      visualization.tokenize != null && visualization.tokenize ? tokenize(text) : [text]\n\n    const seen = new Set<string>()\n    for (const token of tokens) {\n      if (vocabulary[token] === undefined) vocabulary[token] = { value: 0, docFreq: 0 }\n      if (!seen.has(token)) {\n        vocabulary[token].docFreq += 1\n        seen.add(token)\n      }\n      const v = Number(values?.[i]) ?? 1\n      if (!isNaN(v)) vocabulary[token].value += v\n    }\n  }\n  return vocabulary\n}\n\nfunction getTopTerms (\n  vocabulary: Record<string, VocabularyStats>,\n  nDocs: number,\n  topTerms: number\n): ScoredTerm[] {\n  const words = Object.entries(vocabulary)\n    .map(([text, stats]) => {\n      const tf = Math.log(1 + stats.value)\n      const idf = Math.log(nDocs / stats.docFreq)\n      return { text, value: stats.value, importance: tf * idf }\n    })\n    .sort((a, b) => b.importance - a.importance)\n    .slice(0, topTerms)\n\n  const minImportance = Math.min(...words.map((w) => w.importance))\n  const maxImportance = Math.max(...words.map((w) => w.importance))\n\n  return words.map((w) => {\n    return {\n      text: w.text,\n      value: w.value,\n      importance: rescaleToRange(w.importance, minImportance, maxImportance, 0, 1)\n    }\n  })\n}\n","import { PropsUITable, TableContext, TableWithContext } from '../../../../types/elements'\nimport {\n  ChartVisualization,\n  TextVisualization,\n  VisualizationType,\n  VisualizationData\n} from '../../../../types/visualizations'\nimport { prepareChartData } from './visualizationDataFunctions/prepareChartData'\nimport { prepareTextData } from './visualizationDataFunctions/prepareTextData'\n\ninterface Input {\n  table: TableWithContext\n  visualization: VisualizationType\n}\n\nself.onmessage = (e: MessageEvent<Input>) => {\n  createVisualizationData(e.data.table, e.data.visualization)\n    .then((visualizationData) => {\n      self.postMessage({ status: 'success', visualizationData })\n    })\n    .catch((error) => {\n      console.error(error)\n      self.postMessage({ status: 'error', visualizationData: undefined })\n    })\n}\n\nasync function createVisualizationData (\n  table: PropsUITable & TableContext,\n  visualization: VisualizationType\n): Promise<VisualizationData> {\n  if (table === undefined || visualization === undefined) throw new Error('Table and visualization are required')\n\n  if (['line', 'bar', 'area'].includes(visualization.type)) { return await prepareChartData(table, visualization as ChartVisualization) }\n\n  if (['wordcloud'].includes(visualization.type)) { return await prepareTextData(table, visualization as TextVisualization) }\n\n  throw new Error(`Visualization type ${visualization.type} not supported`)\n}\n"],"names":["autoFormatDate","dateNumbers","minValues","minTime","maxTime","getDomain","autoFormat","createSortable","domain","interval","formatter","sortable","intervalNumber","includes","i","datestring","Date","undefined","numbers","min","max","forEach","nr","tokenize","text","split","filter","token","test","getTableColumn","table","column","columnIndex","head","cells","findIndex","cell","Error","id","body","rows","map","row","rescaleToRange","value","newMin","newMax","scaled","isNaN","async","prepareChartData","visualization","length","emptyVisualizationData","aggregate","groupBy","xSortable","group","dateFormat","dateString","format","formattedDate","date","getTime","toISOString","getFullYear","toString","year","quarter","Math","floor","getMonth","month","toLocaleString","day","getDate","hour","Intl","DateTimeFormat","weekday","hour12","sortableDate","formatDate","levels","prepareX","rowIds","xLabel","label","values","some","addZeroes","uniqueValue","sortby","Object","entries","sortBy","xValue","secondAxis","tickerFormat","aggFun","yValues","yGroup","group_by","groupSummary","range","Number","yValue","n","sum","String","push","keys","aggregateData","visualizationData","aggdata","yKeys","data","sort","a","b","d","key","round","__rowIds","__sortBy","createVisualizationData","type","xKey","prepareTextData","topTerms","texts","textColumn","vocabulary","tokens","seen","Set","docFreq","has","add","v","getVocabulary","valueColumn","nDocs","words","stats","tf","log","idf","importance","slice","minImportance","w","maxImportance","getTopTerms","self","onmessage","e","then","postMessage","status","catch","error","console"],"sourceRoot":""}